"use strict";(self.webpackChunkronamosa_github_io=self.webpackChunkronamosa_github_io||[]).push([[5772],{28453:(e,o,n)=>{n.d(o,{R:()=>r,x:()=>a});var s=n(96540);const t={},i=s.createContext(t);function r(e){const o=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:o},e.children)}},91892:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"books/papers/Google3","title":"Google Monorepo Paper","description":"My reading and notes of the Google Paper: \\"Why Google Stores Billions of Lines of Code in a Single Repository\\" by Authors Rachel Potvin & Josh Levenberg.","source":"@site/docs/books/papers/Google3.md","sourceDirName":"books/papers","slug":"/books/papers/Google3","permalink":"/docs/books/papers/Google3","draft":false,"unlisted":false,"editUrl":"https://github.com/ronamosa/ronamosa.github.io/edit/main/website/docs/books/papers/Google3.md","tags":[],"version":"current","lastUpdatedBy":"Ron Amosa","lastUpdatedAt":1758526302000,"frontMatter":{"title":"Google Monorepo Paper"},"sidebar":"docsSidebar","previous":{"title":"\ud83d\udcc4 12 Factor App Methodology - Modern Cloud Application Development Principles","permalink":"/docs/books/12fa"},"next":{"title":"AWS Certified Security \u2013 Specialty (SCS-C01)","permalink":"/docs/study/SCS-C01/"}}');var t=n(74848),i=n(28453);const r={title:"Google Monorepo Paper"},a=void 0,l={},d=[{value:"Notes",id:"notes",level:2},{value:"Key Details",id:"key-details",level:3},{value:"Piper",id:"piper",level:3},{value:"Clients in the Cloud (CitC)",id:"clients-in-the-cloud-citc",level:3},{value:"Tools for Code",id:"tools-for-code",level:3},{value:"Trunk-based Development",id:"trunk-based-development",level:2},{value:"Feature Flags",id:"feature-flags",level:3},{value:"Workflow Best Practices",id:"workflow-best-practices",level:3},{value:"Advantages",id:"advantages",level:2},{value:"Trade-offs",id:"trade-offs",level:2},{value:"Documentation",id:"documentation",level:3},{value:"Code Health",id:"code-health",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const o={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(o.admonition,{type:"info",children:[(0,t.jsxs)(o.p,{children:["My reading and notes of the Google Paper: ",(0,t.jsx)(o.a,{href:"https://dl.acm.org/doi/pdf/10.1145/2854146",children:'"Why Google Stores Billions of Lines of Code in a Single Repository"'})," by Authors Rachel Potvin & Josh Levenberg."]}),(0,t.jsxs)(o.p,{children:["Youtube Version: ",(0,t.jsx)(o.a,{href:"https://www.youtube.com/watch?v=W71BTkUbdqE",children:"here"})]})]}),"\n",(0,t.jsx)(o.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsx)(o.h3,{id:"key-details",children:"Key Details"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"Google uses a custom Version Control System (VCS) called Piper & CitC"}),"\n",(0,t.jsx)(o.li,{children:"Piper distributed across 10 x Data Centres around the world"}),"\n",(0,t.jsx)(o.li,{children:"Piper is used by 95% of Google Developers situated around the globe"}),"\n",(0,t.jsx)(o.li,{children:'Developers use "trunk-based" development at Google'}),"\n",(0,t.jsx)(o.li,{children:"Lot of custom tooling and practices by Google to enable effective use of Monolithic Repo"}),"\n",(0,t.jsx)(o.li,{children:"Google codebase size = 1B files, 86TB of data including 35 millions commits across 18 years."}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"piper",children:"Piper"}),"\n",(0,t.jsx)(o.p,{children:"Google tried looking for a commercial solution for their VCS needs, but couldn't find one so built Piper."}),"\n",(0,t.jsx)(o.p,{children:"All the code commits, 25,000 SE's around the world commiting typically 16,000 changes, 24,000 changes by way of automated systems."}),"\n",(0,t.jsxs)(o.p,{children:["Single large repo on top of Google infra, first ",(0,t.jsx)(o.a,{href:"https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf",children:"Big table"})]}),"\n",(0,t.jsx)(o.admonition,{title:"Big Table",type:"info",children:(0,t.jsx)(o.p,{children:'"Bigtable is a distributed storage system for managing structured data that is designed to scale to a very large size: petabytes of data across thousands of commodity\nservers. "'})}),"\n",(0,t.jsxs)(o.p,{children:["now ",(0,t.jsx)(o.a,{href:"https://research.google/pubs/pub39966/",children:"Spanner"})]}),"\n",(0,t.jsx)(o.admonition,{title:"Google Spanner",type:"info",children:(0,t.jsx)(o.p,{children:'"Spanner is Google\'s scalable, multi-version, globally-distributed, and synchronously-replicated database. It is the first system to distribute data at global scale and support externally-consistent distributed transactions."'})}),"\n",(0,t.jsxs)(o.p,{children:["Piper = dist. over 10 x Google Data Centre's use ",(0,t.jsx)(o.a,{href:"https://en.wikipedia.org/wiki/Paxos_(computer_science)",children:"Paxos algorithm"})," for consistency across replicas."]}),"\n",(0,t.jsx)(o.admonition,{title:"Paxos Algorithm",type:"info",children:(0,t.jsxs)(o.p,{children:[(0,t.jsx)(o.em,{children:"Paxos is a family of protocols for solving consensus in a network of unreliable or fallible processors. Consensus is the process of agreeing on one result among a group of participants. This problem becomes difficult when the participants or their communications may experience failures.[1]"}),"- Wiki"]})}),"\n",(0,t.jsxs)(o.p,{children:["Interesting reference in Googles ",(0,t.jsx)(o.a,{href:"https://sre.google/sre-book/managing-critical-state/",children:'"Site Reliability Engineering"'})," ",(0,t.jsx)(o.em,{children:'"Chapter 23 - Managing Critical State: Distributed Consensus for Reliability"'})," to Paxos Algorithm as SRE would be super interested and invested in distributed systems consistency."]}),"\n",(0,t.jsx)(o.admonition,{title:"System Architecture Patterns",type:"tip",children:(0,t.jsxs)(o.p,{children:["Also check out ",(0,t.jsx)(o.a,{href:"https://sre.google/sre-book/managing-critical-state/",children:"System Architecture Patterns for Distributed Consensus"})," in the Google SRE book."]})}),"\n",(0,t.jsx)(o.p,{children:"Architected for high level of redundancy and optimize latency across 10 x Data Centres"}),"\n",(0,t.jsx)(o.h3,{id:"clients-in-the-cloud-citc",children:"Clients in the Cloud (CitC)"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"CitC is how developers access Piper (VCS)"}),"\n",(0,t.jsx)(o.li,{children:'CitC is a "cloud-based storage backend + Linux-only FUSE file system"'}),"\n",(0,t.jsx)(o.li,{children:"Developers see their workspaces as directories in the file system, and can use normal Unix tools to browse, view edit files without needing to create a local state copy of the files."}),"\n",(0,t.jsx)(o.li,{children:'Workspace is "in the cloud", so change location change machine, developers work state persists independently.'}),"\n",(0,t.jsx)(o.li,{children:"all \"writes\" stored as CitC 'snapshots', so can roll back any writes."}),"\n",(0,t.jsx)(o.li,{children:'Developers see their local changes "overlaid on top" of the full Piper repo'}),"\n",(0,t.jsx)(o.li,{children:"Developers can navigate and edit files across whole codebase"}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"tools-for-code",children:"Tools for Code"}),"\n",(0,t.jsx)(o.p,{children:"A bunch of tools were developed to help Google do monolithic repo at the scale it does, so would be advisable to look at the same if you were to go this route."}),"\n",(0,t.jsx)(o.h2,{id:"trunk-based-development",children:"Trunk-based Development"}),"\n",(0,t.jsx)(o.p,{children:'Developers work at \'HEAD\' (most recent version of code) and the copy or clone is called the "trunk" or main. Difference? Branch-based developement more prone to merge conflicts due to long-lived branches clashing when they finally come back to "main". Trunk has a single consistent view, always and frequently coming back to "main". "Branch-based" unusual and not supported at Google.'}),"\n",(0,t.jsx)(o.p,{children:"Release branches = cut from specific versions of the repo and usually a snapshot of HEAD to maintain stability.\nBug fixes = developed on main."}),"\n",(0,t.jsx)(o.h3,{id:"feature-flags",children:"Feature Flags"}),"\n",(0,t.jsx)(o.p,{children:"old & new code exist behind feature flags (mainly project-specific code, not library code), avoids need for \"developement\" branches and easier to toggle things. Also think 'A/B' testing via flags, which Google uses using flags."}),"\n",(0,t.jsx)(o.h3,{id:"workflow-best-practices",children:"Workflow Best Practices"}),"\n",(0,t.jsxs)(o.p,{children:['CICD i.e. automated testing after almost every commit, to rebuild all affected dependencies. If a change breaks too much stuff, system auto removes it. Google "presubmit" infrastructure does CI and automated testing ',(0,t.jsx)(o.em,{children:"before"})," that code is added to the codebase."]}),"\n",(0,t.jsx)(o.p,{children:'ALL code is reviewed before commit, so there\'s a little culture pressure there to "not commit bad code". Theme here "dont commit bad code" - how to avoid? Code reviews & code ownership.'}),"\n",(0,t.jsx)(o.p,{children:'Code ownership = every directory in the monolith has code ownership of that directory, so they control who can commit code to their codebase/directory. How does it typically work? 1 x code review from a Developer from that codebase and 1 x commit approval from the "code owner" of that directory/codebase.'}),"\n",(0,t.jsxs)(o.blockquote,{children:["\n",(0,t.jsx)(o.p,{children:(0,t.jsx)(o.em,{children:'"Google has developed a number of practices and tools to support its enormous monolithic codebase, including trunk-based development, the distributed source-code repository Piper, the workspace client CitC, and workflow-support-tools, Critique, CodeSearch, Tricorder, and Rosie."'})}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"advantages",children:"Advantages"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:["one source of truth i.e. unified versioning (see ",(0,t.jsx)(o.a,{href:"https://jlbp.dev/what-is-a-diamond-dependency-conflict",children:'"Diamond Dependency Problem"'}),")"]}),"\n",(0,t.jsx)(o.li,{children:"code sharing & re-use - i.e. cos its all in one repo, tools, libraries can be found, shared easily"}),"\n",(0,t.jsx)(o.li,{children:'atomic changes - i.e. developer knows they can change one thing in "the" repo, and it\'s changed for ALL e.g. depdendencies etc.'}),"\n",(0,t.jsx)(o.li,{children:"large-scale refactoring"}),"\n",(0,t.jsx)(o.li,{children:"flexible team boundaries, code ownership i.e. because all in one repo, boundaries and code ownership is marked by directories"}),"\n",(0,t.jsx)(o.li,{children:"code visibility, clear tree structure, means implicit team namespacing."}),"\n"]}),"\n",(0,t.jsx)(o.h2,{id:"trade-offs",children:"Trade-offs"}),"\n",(0,t.jsx)(o.p,{children:"Main costs to this model are:"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsx)(o.li,{children:"tooling investment for dev work and operational work, as the code scales, so does investment in developing and maintaining these tools"}),"\n",(0,t.jsx)(o.li,{children:"codebase complexity e.g. dependency issues, code discovery difficulty"}),"\n",(0,t.jsx)(o.li,{children:'investment in "code health"'}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:'notes on codebase complexity - investments in code search, tools like "grep" get bogged down (discovery) as codebase scales. argument that developers searching and finding other tools and API\'s to use is good for code re-use, but also creates over dependency (or too easy to add deps) of existing code vs thinking-out your own code or API design, make retro code clean up messier/error-prone.'}),"\n",(0,t.jsx)(o.p,{children:"devs need to be aware of their dependency graphs, and unnecessary deps can lead to downstream build breaks."}),"\n",(0,t.jsx)(o.h3,{id:"documentation",children:"Documentation"}),"\n",(0,t.jsx)(o.p,{children:"This was super interesting:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-text",children:"The fact that most Google code is\navailable to all Google developers has\nled to a culture where some teams ex-\npect other developers to read their\ncode rather than providing them with\nseparate user documentation.\n"})}),"\n",(0,t.jsx)(o.p,{children:'the classic "just read the code", the advantage for the anti-documentation engineer was "no effort required for writing & maintaining docs", but one aspect I have never considered was this...'}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-text",children:"but devel-\nopers sometimes read more than the\nAPI code and end up relying on under-\nlying implementation details. This be-\nhavior can create a maintenance bur-\nden for teams that then have trouble\ndeprecating features they never meant\nto expose to users\n"})}),"\n",(0,t.jsxs)(o.p,{children:["Where the external team, bases their work on the ",(0,t.jsx)(o.em,{children:"underlying"})," implementation of your code/API, and now your team can't mess with that to move your own code off somewhere else, because the external team is dependent on that which locks you in as well!"]}),"\n",(0,t.jsx)(o.h3,{id:"code-health",children:"Code Health"}),"\n",(0,t.jsx)(o.p,{children:"lots of tools to maintain code health that auto removes dead code, splits up large refactors, auto-assigns code reviews. but sounds like there's a big human toll of managing this clean up and health work for the code, including simple refactoring that need eyeballs and reviews because its codebase-wide."}),"\n",(0,t.jsx)(o.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(o.p,{children:"Basically, while it can be done:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-text",children:"At Google, we have found, with some\ninvestment, the monolithic model of\nsource management can scale success-\nfully to a codebase with more than one\nbillion files, 35 million commits, and\nthousands of users around the globe. \n"})}),"\n",(0,t.jsx)(o.p,{children:"doesn't mean its for everyone"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-text",children:"The monolithic model of source\ncode management is not for everyone.\nIt is best suited to organizations like\nGoogle, with an open and collabora-\ntive culture. It would not work well\nfor organizations where large parts\nof the codebase are private or hidden\nbetween groups.\n"})})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);