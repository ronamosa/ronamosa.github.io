"use strict";(self.webpackChunkronamosa_github_io=self.webpackChunkronamosa_github_io||[]).push([[1780],{16486:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"study/Golang/go-the-complete-developers-guide","title":"The Complete Developers Guide (Golang)","description":"Overview","source":"@site/docs/study/Golang/go-the-complete-developers-guide.md","sourceDirName":"study/Golang","slug":"/study/Golang/go-the-complete-developers-guide","permalink":"/docs/study/Golang/go-the-complete-developers-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/ronamosa/ronamosa.github.io/edit/main/website/docs/study/Golang/go-the-complete-developers-guide.md","tags":[],"version":"current","lastUpdatedBy":"Ron Amosa","lastUpdatedAt":1771617957000,"frontMatter":{"title":"The Complete Developers Guide (Golang)"},"sidebar":"docsSidebar","previous":{"title":"Exam Notes","permalink":"/docs/study/CKA/ExamNotes"},"next":{"title":"\ud83c\udff4\u200d\u2620\ufe0f Hacker","permalink":"/docs/category/\ufe0f-hacker"}}');var r=s(74848),t=s(28453);const c={title:"The Complete Developers Guide (Golang)"},o=void 0,a={},d=[{value:"Overview",id:"overview",level:2},{value:"Notes",id:"notes",level:2},{value:"Simple Start",id:"simple-start",level:2},{value:"run code",id:"run-code",level:3},{value:"package main",id:"package-main",level:3},{value:"import fmt",id:"import-fmt",level:3},{value:"func",id:"func",level:3},{value:"main.go organized",id:"maingo-organized",level:3},{value:"Deeper into Go",id:"deeper-into-go",level:2},{value:"variable declaration",id:"variable-declaration",level:3},{value:"functions",id:"functions",level:3},{value:"slice and for Loops",id:"slice-and-for-loops",level:3},{value:"oo vs go",id:"oo-vs-go",level:3},{value:"card deck go program",id:"card-deck-go-program",level:3},{value:"custom types and receiver functions",id:"custom-types-and-receiver-functions",level:3},{value:"slice range syntax",id:"slice-range-syntax",level:3},{value:"deck to string",id:"deck-to-string",level:3},{value:"join slice of Strings",id:"join-slice-of-strings",level:3},{value:"save data to HDD",id:"save-data-to-hdd",level:3},{value:"read data from HDD",id:"read-data-from-hdd",level:3},{value:"error handling",id:"error-handling",level:3},{value:"Summary",id:"summary",level:2},{value:"Assignment 1",id:"assignment-1",level:2},{value:"Data Structures",id:"data-structures",level:2},{value:"structs",id:"structs",level:3},{value:"updating struct values",id:"updating-struct-values",level:3},{value:"embedded structs",id:"embedded-structs",level:3},{value:"structs receiver functions",id:"structs-receiver-functions",level:3},{value:"pointers",id:"pointers",level:3},{value:"Pointer Operations",id:"pointer-operations",level:3},{value:"Shortcuts",id:"shortcuts",level:3},{value:"Pointer Gotchas",id:"pointer-gotchas",level:2},{value:"struct vs slice",id:"struct-vs-slice",level:3},{value:"reference vs value types",id:"reference-vs-value-types",level:3},{value:"Maps",id:"maps",level:2},{value:"Maps vs Structs",id:"maps-vs-structs",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Purpose of interfaces",id:"purpose-of-interfaces",level:3},{value:"Rules of Interfaces",id:"rules-of-interfaces",level:3},{value:"The HTTP Package",id:"the-http-package",level:3},{value:"Writer Interface",id:"writer-interface",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["My notes of the ",(0,r.jsx)(n.a,{href:"https://www.udemy.com/course/go-the-complete-developers-guide",children:'"Go: The Complete Developers Guide (Golang)"'})," course on Udemy to learn Golang."]})}),"\n",(0,r.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsx)(n.p,{children:"From Simple Start Chapter, questions:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"how do we run the code in our project?"}),"\n",(0,r.jsxs)(n.li,{children:["what does ",(0,r.jsx)(n.code,{children:"package main"})," mean?"]}),"\n",(0,r.jsxs)(n.li,{children:["what does ",(0,r.jsx)(n.code,{children:'import "fmt"'})," mean?"]}),"\n",(0,r.jsxs)(n.li,{children:["what's that ",(0,r.jsx)(n.code,{children:"func"})," thing?"]}),"\n",(0,r.jsxs)(n.li,{children:["how is the ",(0,r.jsx)(n.code,{children:"main.go"})," file organized"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"simple-start",children:"Simple Start"}),"\n",(0,r.jsx)(n.h3,{id:"run-code",children:"run code"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"go run main.go"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"go run = compile & run"}),"\n",(0,r.jsx)(n.li,{children:"go build = just compile"}),"\n",(0,r.jsx)(n.li,{children:"go install, go get = installs pkg, download raw source code"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"package-main",children:"package main"}),"\n",(0,r.jsx)(n.p,{children:"package == project == workspace"}),"\n",(0,r.jsxs)(n.p,{children:['all files belonging to that "package" must declare so at the top with ',(0,r.jsx)(n.code,{children:"package main"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"2 types of package = executable (runnable) and reusable (a 'helper', good for logic, libs)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"package main"}),' is SACRED! only use it if you want to create a "runnable" file. a "non-main" package, compiles but does NOT run anything.']}),"\n",(0,r.jsxs)(n.p,{children:["any executable package main ",(0,r.jsx)(n.strong,{children:"must"})," have a ",(0,r.jsx)(n.code,{children:"func main"})," in it."]}),"\n",(0,r.jsxs)(n.p,{children:["rename package to anything else and do ",(0,r.jsx)(n.code,{children:"go build"})," does NOT build any executable file."]}),"\n",(0,r.jsx)(n.h3,{id:"import-fmt",children:"import fmt"}),"\n",(0,r.jsxs)(n.p,{children:["gives us access to ",(0,r.jsx)(n.code,{children:"fmt"})," library/package."]}),"\n",(0,r.jsx)(n.h3,{id:"func",children:"func"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fun main() {"})," - short for function."]}),"\n",(0,r.jsx)(n.h3,{id:"maingo-organized",children:"main.go organized"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"package declaration"}),"\n",(0,r.jsx)(n.li,{children:"imports packages"}),"\n",(0,r.jsx)(n.li,{children:"func main"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"deeper-into-go",children:"Deeper into Go"}),"\n",(0,r.jsx)(n.h3,{id:"variable-declaration",children:"variable declaration"}),"\n",(0,r.jsxs)(n.p,{children:["this ",(0,r.jsx)(n.code,{children:"var Name string"})," and ",(0,r.jsx)(n.code,{children:'name := "Ron"'})," are EQUIVALENT in variable initialization and (initial) assignment the ",(0,r.jsx)(n.code,{children:":="})," will determine the type for you."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:":="}),' use only when declaring new vars, dont use for value "assignment".']}),"\n",(0,r.jsx)(n.h3,{id:"functions",children:"functions"}),"\n",(0,r.jsxs)(n.p,{children:["when writing up non-main functions, this is the format ",(0,r.jsx)(n.code,{children:"func funcName() typeToReturn"})," e.g. ",(0,r.jsx)(n.code,{children:"func newCard() string {"})," you'll get an error message if return type and return value type are mismatched."]}),"\n",(0,r.jsx)(n.h3,{id:"slice-and-for-loops",children:"slice and for Loops"}),"\n",(0,r.jsx)(n.p,{children:"Array = fixed list\nSlice = array that can grow/shrink"}),"\n",(0,r.jsxs)(n.p,{children:["the TYPES in a slice ",(0,r.jsx)(n.strong,{children:"must be of the same type."})]}),"\n",(0,r.jsxs)(n.p,{children:["declare a slice: ",(0,r.jsx)(n.code,{children:'cards := []string{"elements","inside","slice"}'}),". the ",(0,r.jsx)(n.code,{children:"[]"})," and ",(0,r.jsx)(n.code,{children:"string"}),' declares its a "slice" of type "string", and then ',(0,r.jsx)(n.code,{children:"{}"})," to hold the elements of the slice."]}),"\n",(0,r.jsxs)(n.p,{children:["adding elements to a slice: ",(0,r.jsx)(n.code,{children:'cards = append(cards, "newElement")'}),' important to note here that the original "cards" slice is not modified with this new element, instead a NEW slice with the appended element is returned.']}),"\n",(0,r.jsxs)(n.p,{children:["iterate over a slice, print every element: ",(0,r.jsx)(n.code,{children:"for i, card := range cards { fmt.Println(i, card)}"})]}),"\n",(0,r.jsx)(n.p,{children:"i = index, range = iterate over every element in slice."}),"\n",(0,r.jsx)(n.h3,{id:"oo-vs-go",children:"oo vs go"}),"\n",(0,r.jsx)(n.p,{children:"Go is NOT OO language."}),"\n",(0,r.jsxs)(n.p,{children:["Think - go types (string, int, float, array, map), then extend ",(0,r.jsx)(n.code,{children:"type deck []string"}),", then functions"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"main.go"})," - our main program that manipulates the deck"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"deck.go"})," - describe deck, how it works (spec?)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"deck_test.go"})," - automatically test our deck"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"card-deck-go-program",children:"card deck go program"}),"\n",(0,r.jsx)(n.p,{children:"For our card app, what functions do we want?"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"newDeck - create return list of playing cards (array of strings)"}),"\n",(0,r.jsx)(n.li,{children:"print"}),"\n",(0,r.jsx)(n.li,{children:"shuffle"}),"\n",(0,r.jsx)(n.li,{children:"deal"}),"\n",(0,r.jsx)(n.li,{children:"saveToFile"}),"\n",(0,r.jsx)(n.li,{children:"newDeckFromFile"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"add the custom types and receivers as necessary."}),"\n",(0,r.jsx)(n.h3,{id:"custom-types-and-receiver-functions",children:"custom types and receiver functions"}),"\n",(0,r.jsx)(n.p,{children:'we can do something like this to sort of simulate "extends" from OO approach'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"// in a separate .go file\n\n// declare new type\ntype deck []string\n\n// create custom method for new type\nfunc (d deck) print() {\n  for i, card := range d {\n      fmt.Println(i, card)\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We declared a custom type with ",(0,r.jsx)(n.code,{children:"type deck []string"})," and can now use ",(0,r.jsx)(n.code,{children:"deck"}),' "type" anywhere in our main package code.']}),"\n",(0,r.jsxs)(n.p,{children:["Printing the new type out now made easier with our ",(0,r.jsx)(n.code,{children:"print()"})," function."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"(d deck)"})," is the bit that makes this func a ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:'"receiver function"'})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A receiver sets up methods on variables we create e.g. we create var ",(0,r.jsx)(n.code,{children:"card"})," of type ",(0,r.jsx)(n.code,{children:"deck"}),", and now the print func can be setup on ANY var of type ",(0,r.jsx)(n.code,{children:"deck"})," e.g. ",(0,r.jsx)(n.code,{children:"card.print()"})]}),"\n",(0,r.jsxs)(n.p,{children:["Think of ",(0,r.jsx)(n.code,{children:"d"})," arg as ",(0,r.jsx)(n.code,{children:"this"})," or ",(0,r.jsx)(n.code,{children:"self"}),' - in go, never use "this" or "self", and also always refer to the THING that you\'re setting method up on, by convention if your type is ',(0,r.jsx)(n.code,{children:"deck"})," your arg name will be ",(0,r.jsx)(n.code,{children:"d"}),", but you can do whatever as long as the references match i.e. ",(0,r.jsx)(n.code,{children:"(d deck)"})," and ",(0,r.jsx)(n.code,{children:"range d"})," match."]}),"\n",(0,r.jsxs)(n.p,{children:["If you have a var that you don't care to use, and want to avoid the \"you declared but haven't used this var\" error message, replace them with ",(0,r.jsx)(n.code,{children:"_"})," underscore."]}),"\n",(0,r.jsx)(n.p,{children:"e.g."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (d deck) print() {\n  for i, card := range d {\n    fmt.Println(i, card)\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"slice-range-syntax",children:"slice range syntax"}),"\n",(0,r.jsx)(n.p,{children:'Dealing out a "hand", a slice of the 52 available cards.'}),"\n",(0,r.jsxs)(n.p,{children:["slices indexed from ",(0,r.jsx)(n.code,{children:"0"}),", e.g. ",(0,r.jsx)(n.code,{children:"fruits[0]"})]}),"\n",(0,r.jsxs)(n.p,{children:["for a subset, or range of the slice: ",(0,r.jsx)(n.code,{children:"fruits[0:2]"})," will give you fruits of index 0,1 cos the first index ",(0,r.jsx)(n.code,{children:"0"}),' is "inclusive", but the 2nd index ',(0,r.jsx)(n.code,{children:"2"}),' is "up to, but NOT including" ',(0,r.jsx)(n.code,{children:"2"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["shorthand for this can be ",(0,r.jsx)(n.code,{children:"[:2]"})," is the same as ",(0,r.jsx)(n.code,{children:"[0:2]"}),", another example is ",(0,r.jsx)(n.code,{children:"[2:]"})," is the same as ",(0,r.jsx)(n.code,{children:"[2:n]"}),' i.e. "from index 2 until the end of the index"']}),"\n",(0,r.jsxs)(n.p,{children:["when returning 2 x type deck values from the function, you assign them to two variables like this: ",(0,r.jsx)(n.code,{children:"hand, remainingDeck := deal(cards, 5)"}),", because ",(0,r.jsx)(n.code,{children:"deal(cards, 5)"})," gets ",(0,r.jsx)(n.code,{children:"(deck, deck)"})," from the receiver function."]}),"\n",(0,r.jsx)(n.h3,{id:"deck-to-string",children:"deck to string"}),"\n",(0,r.jsxs)(n.p,{children:["trying to save to file, ",(0,r.jsx)(n.code,{children:"import io/ioutil"})," we need to transfer our strings to a ",(0,r.jsx)(n.code,{children:"[]byte"}),' "byte slice".']}),"\n",(0,r.jsx)(n.p,{children:'a way to do a "type conversion":'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'greeting = "Hi there!"\nfmt.Println([]byte(greeting)) // changes the greeting string into a byte slice.\n'})}),"\n",(0,r.jsxs)(n.p,{children:["our process = start with ",(0,r.jsx)(n.code,{children:"deck"})," --\x3e ",(0,r.jsx)(n.code,{children:"[]string"})," --\x3e ",(0,r.jsx)(n.code,{children:"string"})," --\x3e ",(0,r.jsx)(n.code,{children:"[]byte"})]}),"\n",(0,r.jsxs)(n.p,{children:["the ",(0,r.jsx)(n.code,{children:"string"})," is ALL card strings smashed together to then convert to a ",(0,r.jsx)(n.code,{children:"[]byte"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"join-slice-of-strings",children:"join slice of Strings"}),"\n",(0,r.jsxs)(n.p,{children:["lookup and use ",(0,r.jsx)(n.code,{children:"strings"})," library ",(0,r.jsx)(n.code,{children:"Join"})," function."]}),"\n",(0,r.jsx)(n.h3,{id:"save-data-to-hdd",children:"save data to HDD"}),"\n",(0,r.jsxs)(n.p,{children:["lookup and use ",(0,r.jsx)(n.code,{children:"io/iotuil"})," library ",(0,r.jsx)(n.code,{children:"WriteFile"})," function for writing a ",(0,r.jsx)(n.code,{children:"[]byte"}),' byte slice to disk under "filename".']}),"\n",(0,r.jsx)(n.h3,{id:"read-data-from-hdd",children:"read data from HDD"}),"\n",(0,r.jsxs)(n.p,{children:["use ",(0,r.jsx)(n.code,{children:"io/ioutil"})," functions ",(0,r.jsx)(n.code,{children:"ReadFile"})," to do the reverse and open a file from HDD, then use ",(0,r.jsx)(n.code,{children:"strings"})," function ",(0,r.jsx)(n.code,{children:"Split"})," to reverse what you did with ",(0,r.jsx)(n.code,{children:"Join"}),", now you have a ",(0,r.jsx)(n.code,{children:"[]string"})," string slice AKA a ",(0,r.jsx)(n.code,{children:"deck type"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"error handling"}),"\n",(0,r.jsxs)(n.p,{children:["the ",(0,r.jsx)(n.code,{children:"err"})," convention"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'...\nif err != nil {\n    fmt.Println("Error:", err)\n    os.Exit(1)\n  }\n'})}),"\n",(0,r.jsxs)(n.p,{children:["make sure to ",(0,r.jsx)(n.code,{children:"import os"}),", and any non-zero number inside ",(0,r.jsx)(n.code,{children:"Exit()"})," to signal a bad exit."]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["create ",(0,r.jsx)(n.code,{children:"type deck"})]}),"\n",(0,r.jsxs)(n.li,{children:["tie methods to the new ",(0,r.jsx)(n.code,{children:"type deck"})," using ",(0,r.jsx)(n.em,{children:'"receiver functions"'})]}),"\n",(0,r.jsxs)(n.li,{children:["receivers = can tack onto the type deck e.g. ",(0,r.jsx)(n.code,{children:"cards.print()"})]}),"\n",(0,r.jsxs)(n.li,{children:["no receiver for methods like ",(0,r.jsx)(n.code,{children:".deal()"}),' because the "root" instance of the deck (??)']}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"assignment-1",children:"Assignment 1"}),"\n",(0,r.jsx)(n.p,{children:"write a go program that iterates over a range of numbers and evaluates even and odd and prints a statement to each."}),"\n",(0,r.jsx)(n.p,{children:"my solution:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc main() {\n    numbers := []int{1,2,3,4,5,6,7,8,9,10}\n\n    for _, num := range numbers {\n        if num % 2 == 0 {\n            fmt.Println(num, " is even.")\n        } else {\n            fmt.Println(num, " is odd.")\n          }\n        }\n      }\n  }\n'})}),"\n",(0,r.jsx)(n.h2,{id:"data-structures",children:"Data Structures"}),"\n",(0,r.jsx)(n.h3,{id:"structs",children:"structs"}),"\n",(0,r.jsx)(n.p,{children:'aka data structures are a "collection of properties that are related together".'}),"\n",(0,r.jsx)(n.p,{children:'we first define a "structure" e.g. of a person, then we create instances of people.'}),"\n",(0,r.jsx)(n.p,{children:"e.g."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type person struct {\n    firstName string\n    lastName string\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["few different ways to construct ",(0,r.jsx)(n.code,{children:"struct"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:'alex := person{firstName: "Alex", lastName: "Anderson"}'})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"var alex person"})," then init with ",(0,r.jsx)(n.code,{children:'alex.firstName = "Alex"'})," and ",(0,r.jsx)(n.code,{children:'alex.lastName = "Anderson"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"var alex person"})," then ",(0,r.jsx)(n.code,{children:'fmt.Printf("%+v", alex)'})," with ",(0,r.jsx)(n.code,{children:"%+v"})," printing out field names and values."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"updating-struct-values",children:"updating struct values"}),"\n",(0,r.jsxs)(n.p,{children:["if you don't init the vars with values, if string they get assigned ",(0,r.jsx)(n.code,{children:'""'})," empty string value.\nif bool or int, they get ",(0,r.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["so if you ",(0,r.jsx)(n.code,{children:"fmt.Println(alex)"})," with no value assigned, you get ",(0,r.jsx)(n.code,{children:"{ }"}),' printed out i.e. "empty strings"']}),"\n",(0,r.jsxs)(n.p,{children:["using ",(0,r.jsx)(n.code,{children:"fmt.Printf()"})," and syntax ",(0,r.jsx)(n.code,{children:'fmt.Printf("%+v", alex)'})," as the 3rd way to show structs."]}),"\n",(0,r.jsx)(n.p,{children:"final form :"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\ntype person struct {\n  firstName string\n  lastName string\n}\n\nfunc main() {\n  //alex := person{firstName: "Alex", lastName: "Anderson"} // version 1\n\n  var alex person // version 2\n\n  alex.firstName = "Alex"\n  alex.lastName = "Anderson"\n\n  fmt.Println(alex)\n  fmt.Printf("%+v", alex)\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"embedded-structs",children:"embedded structs"}),"\n",(0,r.jsx)(n.p,{children:"embed on struct inside another struct."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type person\ntype contactInfo\n"})}),"\n",(0,r.jsx)(n.p,{children:"you can use custom types inside our structs."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\ntype contactInfo struct {\n  email string\n  zipCode int\n}\n\ntype person struct {\n  firstName string\n  lastName string\n  contact contactInfo\n}\n\nfunc main() {\n  jim := person{\n    firstName: "Jim",\n    lastName: "Party",\n    contact: contactInfo{\n      email: "jim@gmail.com",\n      zipCode: 94000,\n    },\n  }\n  fmt.Printf("%+v", jim)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["another method of declaring our ",(0,r.jsx)(n.code,{children:"contactInfo"})," is to remove the explicit variable name ",(0,r.jsx)(n.code,{children:"contact"})," and just do the following:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type person struct {\n  firstName string\n  lastName string\n  contactInfo\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"and then"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'function main() {\n  jim := person{\n    firstName: "Jim",\n    lastName: "Party",\n    contactInfo: contactInfo{\n      email: "jim@gmail.com",\n      zipCode: 94000,\n    },\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"structs-receiver-functions",children:"structs receiver functions"}),"\n",(0,r.jsx)(n.p,{children:"recap receiver functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"func (letter type) funcName(varName varType) { }\n\n// e.g. func (p person) updateName(newFirstName string)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pointers",children:"pointers"}),"\n",(0,r.jsx)(n.p,{children:"the reason the updateName function did not work."}),"\n",(0,r.jsxs)(n.p,{children:["Go is a ",(0,r.jsx)(n.em,{children:'"pass by values"'})," means you work on a COPY of the value of the object/thing, not the original object/thing."]}),"\n",(0,r.jsxs)(n.p,{children:["e.g. we contruct the ",(0,r.jsx)(n.code,{children:'person{firstName: "Jim"...}'})," person, but when we pass the value to our function for a name update ",(0,r.jsx)(n.code,{children:"func (p person) updateName(newFirstName string)"}),", it creates a copy ",(0,r.jsx)(n.code,{children:"p"})," of the person Jim:"]}),"\n",(0,r.jsxs)(n.p,{children:["|RAM|\n|---|---|\n|Address|Value|\n|0000||\n|0001|",(0,r.jsx)(n.code,{children:'person{firstName: "Jim"...}'}),"|\n|0002||\n|0003|",(0,r.jsx)(n.code,{children:'person{firstName: "Jim"...}'}),"|"]}),"\n",(0,r.jsxs)(n.p,{children:["original Jim object at ",(0,r.jsx)(n.code,{children:"0001"}),', "newFirstName" Jim object (i.e. ',(0,r.jsx)(n.code,{children:"p"}),") at ",(0,r.jsx)(n.code,{children:"0003"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["to summarize, when ",(0,r.jsx)(n.code,{children:"updateName"})," is called, go makes a COPY of that struct, and then makes the COPY (",(0,r.jsx)(n.code,{children:"p"}),") available to the function for processing."]}),"\n",(0,r.jsx)(n.p,{children:"why does go do this?"}),"\n",(0,r.jsx)(n.h3,{id:"pointer-operations",children:"Pointer Operations"}),"\n",(0,r.jsxs)(n.admonition,{title:"operators",type:"info",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"&"})," creates a memory ADDRESS pointer"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"*"})," creates a memory VALUE pointer"]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"&jim"}),' = "give me the memory address of the value this variable is pointing to"']}),"\n",(0,r.jsxs)(n.p,{children:["so ",(0,r.jsx)(n.code,{children:"jimPointer := &jim"})," is now pointing to the MEMORY ADDRESS of whatever ",(0,r.jsx)(n.code,{children:"&jim"})," evaluated to."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"*pointer"}),' = "give me the value this memory address is pointing to"']}),"\n",(0,r.jsxs)(n.p,{children:["so ",(0,r.jsx)(n.code,{children:"func(pointerToPerson *person)"})," says give me the VALUE at the pointer where this ",(0,r.jsx)(n.code,{children:"*pointer"})," memory address is pointing."]}),"\n",(0,r.jsx)(n.p,{children:"understand difference between pointer as a TYPE and as a POINTER:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["pointer in front of a type e.g. ",(0,r.jsx)(n.code,{children:"func (pointerToPerson *person)"}),' means this receiver can only accept a type of a "pointer to a person" i.e. something like ',(0,r.jsx)(n.code,{children:"jimPointer"})]}),"\n",(0,r.jsxs)(n.li,{children:["pointer in front of a pointer e.g. ",(0,r.jsx)(n.code,{children:"(*pointerToPerson).firstName"})]}),"\n"]}),"\n",(0,r.jsxs)(n.admonition,{title:"Rules to Remember",type:"tip",children:[(0,r.jsxs)(n.p,{children:["use ",(0,r.jsx)(n.code,{children:"*address"})," to turn an address into value."]}),(0,r.jsxs)(n.p,{children:["use ",(0,r.jsx)(n.code,{children:"&value"})," to turn a value into address."]})]}),"\n",(0,r.jsx)(n.h3,{id:"shortcuts",children:"Shortcuts"}),"\n",(0,r.jsx)(n.p,{children:"with this code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'  jimPointer := &jim\n  jimPointer.updateName("jimmy")\n  jim.print()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["you can remove ",(0,r.jsx)(n.code,{children:"jimPointer := &jim"}),", and the ",(0,r.jsx)(n.code,{children:"func (pointerToPerson *person)"}),' will automatically take your "type person" and turn it into a "pointer person (',(0,r.jsx)(n.code,{children:"*person"}),')" for you.']}),"\n",(0,r.jsx)(n.h2,{id:"pointer-gotchas",children:"Pointer Gotchas"}),"\n",(0,r.jsx)(n.h3,{id:"struct-vs-slice",children:"struct vs slice"}),"\n",(0,r.jsx)(n.p,{children:"with struct, you need pointers to update the actual values."}),"\n",(0,r.jsx)(n.p,{children:"with stlices - values seem to update directly as you act upon the values."}),"\n",(0,r.jsx)(n.h3,{id:"reference-vs-value-types",children:"reference vs value types"}),"\n",(0,r.jsx)(n.p,{children:"Arrays vs Slices - arrays are primitive, can't be resized. we use slices more."}),"\n",(0,r.jsx)(n.p,{children:'A slice gives us BOTH a slice data structure (ptr, capacity, length) and array data structure (ptr points to the elements in our slice "array").'}),"\n",(0,r.jsx)(n.p,{children:"in memory, our SLICE is registered as the slice data structure at one memory address, and the actual array with our elements in it at another memory address."}),"\n",(0,r.jsxs)(n.p,{children:["when the ",(0,r.jsx)(n.em,{children:'"pass by value"'})," happens when we pass our slice to a function, the COPY go makes of the slice is just the SLICE data structure, which goes into another address- BUT, this COPY still points to the SAME ARRAY values the original slice data structure points to."]}),"\n",(0,r.jsx)(n.p,{children:"so when we modify the SLICE, we are not modifying a COPY of the array values for the slice, there is no COPY, we are modifying the original array values from the slice."}),"\n",(0,r.jsx)(n.p,{children:'slice is a "reference" type - it a data structure that refers to ANOTHER data structure in RAM.'}),"\n",(0,r.jsxs)(n.admonition,{title:"Types",type:"info",children:[(0,r.jsx)(n.p,{children:"Reference types:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"maps"}),"\n",(0,r.jsx)(n.li,{children:"channels"}),"\n",(0,r.jsx)(n.li,{children:"pointers"}),"\n",(0,r.jsx)(n.li,{children:"functions."}),"\n"]}),(0,r.jsx)(n.p,{children:"value types:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"int"}),"\n",(0,r.jsx)(n.li,{children:"float"}),"\n",(0,r.jsx)(n.li,{children:"string"}),"\n",(0,r.jsx)(n.li,{children:"bool"}),"\n",(0,r.jsx)(n.li,{children:"structs."}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"maps",children:"Maps"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"# MAP\nkey --\x3e value\nkey --\x3e value\nkey --\x3e value\n"})}),"\n",(0,r.jsx)(n.p,{children:"comparably: map(go) = hash(ruby) = object(javascript) = dict(python)"}),"\n",(0,r.jsx)(n.p,{children:"Maps = statically typed i.e. all keys = same type, all values = same type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc main() {\n\n  // 2 x ways of init a "null" map:\n  // 1. var colors map[string]string\n  // 2. colors := make(map[string]string)\n\n  // example of using type=int\n  // colors := make(map[int]string)\n  // colors[10] = "#ffffff"\n  // delete(colors, 10)\n  // fmt.Println(color)\n\n  colors := map[string]string{\n    "red":   "#ff0000",\n    "green": "#00ff00",\n    "white": "#ffffff",\n  }\n\n  printMap(colors)\n}\n\nfunc printMap(c map[string]string) {\n  // iterate over a map\n  for color, hex := range c {\n    fmt.Println("Hex code for", color, "is", hex)\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Always use ",(0,r.jsx)(n.code,{children:"[]"})," braces with maps e.g. ",(0,r.jsx)(n.code,{children:'color["white"] = "#ffffff'}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Let's break down the func, loop"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// c = argument\n// map[string]string = type of the argument\n// color, hex = the variables that will receive the `key, value` during the loop\n// range c = "iterate over the range \'c\'"\n\nfunc printMap(c map[string]string) {\n  // iterate over a map\n  for color, hex := range c {\n    fmt.Println("Hex code for", color, "is", hex)\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"maps-vs-structs",children:"Maps vs Structs"}),"\n",(0,r.jsx)(n.p,{children:"Maps = statically typed = all keys and values must be same type.\nStruct = values can be different type."}),"\n",(0,r.jsx)(n.p,{children:"Maps = keys are indexed 0...12, can iterate over.\nStruct = keys dont support index, can't interate over."}),"\n",(0,r.jsx)(n.p,{children:"Maps = original data structure of map directly modified\nStructs = original data structure is copied, and edited, original is unmodified."}),"\n",(0,r.jsx)(n.admonition,{title:"When to use Maps?",type:"tip",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"when representing a set of collection of closely related properties"}),"\n",(0,r.jsx)(n.li,{children:"when your scenario doesn't know all keys, types at compile time (otherwise, look at structs if you know)"}),"\n"]})}),"\n",(0,r.jsx)(n.p,{children:"vast majority of golang = use structs."}),"\n",(0,r.jsx)(n.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,r.jsx)(n.h3,{id:"purpose-of-interfaces",children:"Purpose of interfaces"}),"\n",(0,r.jsx)(n.p,{children:"reuse, generic code or code that has common factors - write an interface instead of duplicate code."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\ntype bot interface {\n  getGreeting() string\n}\n\ntype englishBot struct{}\ntype spanishBot struct{}\n\nfunc main() {\n  eb := englishBot{}\n  sb := spanishBot{}\n\n  printGreeting(eb)\n  printGreeting(sb)\n}\n\nfunc printGreeting(b bot) {\n  fmt.Println(b.getGreeting())\n}\n\nfunc (eb englishBot) getGreeting() string {\n  // very custom logic for generating english greeting\n  return "Hi there!"\n}\n\nfunc (sb spanishBot) getGreeting() string {\n  return "Hola!"\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Create a new type ",(0,r.jsx)(n.code,{children:"bot"})," that says, if you have a ",(0,r.jsx)(n.code,{children:"getGreeting()"})," function, with return type ",(0,r.jsx)(n.code,{children:"string"}),", you can be type cast as ",(0,r.jsx)(n.code,{children:"bot"})," and use what ",(0,r.jsx)(n.code,{children:"bot"})," can use i.e. ",(0,r.jsx)(n.code,{children:"printGreeting()"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"rules-of-interfaces",children:"Rules of Interfaces"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type bot interface {\n\n  // input args = string, int\n  // returns = string, error\n  getGreeting(string, int) (string, error)\n\n  // input args = none\n  // returns = float\n  getBotVersion() float\n\n  // input args = user\n  // returns = string\n  respondToUser(user) string\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Concrete Types = map, struct, int, englishBot, string -- ",(0,r.jsx)(n.strong,{children:"can"})," create values directly e.g. ",(0,r.jsx)(n.code,{children:"int a := 12"}),"\nInterface Type = bot -- ",(0,r.jsx)(n.strong,{children:"can't"}),' create value directly i.e. bot can\'t "equal 5"']}),"\n",(0,r.jsx)(n.p,{children:"Some key interface points:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Interfaces are NOT generic types."}),"\n",(0,r.jsxs)(n.li,{children:["Interfaces are implicit i.e. when you declare a ",(0,r.jsx)(n.code,{children:"type bot interface"})," and then do a ",(0,r.jsx)(n.code,{children:"type englishBot struct{}"}),", go will implicitly treat ",(0,r.jsx)(n.code,{children:"englishBot"})," as type ",(0,r.jsx)(n.code,{children:"bot interface"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Interfaces are a contract to help us manages types."}),"\n",(0,r.jsx)(n.li,{children:"Interfaces only help reuse code, doesn't check logic or test things for you, garbage in = garbage out."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"the-http-package",children:"The HTTP Package"}),"\n",(0,r.jsx)(n.p,{children:"A program that:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"HTTP request --\x3e google.com"}),"\n",(0,r.jsx)(n.li,{children:"print response to terminal"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Get used to following the docs:"}),"\n",(0,r.jsx)(n.p,{children:'e.g. we are looking for where the "Body" of the HTTP request we made is, so we follow the code'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://pkg.go.dev/net/http#Get",children:"https://pkg.go.dev/net/http#Get"})," --\x3e ",(0,r.jsx)(n.code,{children:"func Get(url string) (resp *Response, err error)"})," --\x3e ",(0,r.jsx)(n.a,{href:"https://pkg.go.dev/net/http#Response",children:"https://pkg.go.dev/net/http#Response"})," --\x3e ",(0,r.jsx)(n.code,{children:"Body io.ReadCloser"})," --\x3e ",(0,r.jsx)(n.a,{href:"https://pkg.go.dev/io#ReadCloser",children:"https://pkg.go.dev/io#ReadCloser"})," --\x3e ",(0,r.jsx)(n.code,{children:"type ReadCloser interface"})," --\x3e ",(0,r.jsx)(n.a,{href:"https://pkg.go.dev/io#Reader",children:"https://pkg.go.dev/io#Reader"})]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:['my thought: interfaces re-packages the data into a form that is generic enough, to be consumed by general code e.g. the Reader interface accepts all sources of Input and then "output" it to a ',(0,r.jsx)(n.code,{children:"byte[]"})," slice, and that's a generic enough type to be handled by anything on the other side of the interface."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-golang",children:"type Reader interface {\n  Read(p []byte) (n int, err error)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["this interface, has func ",(0,r.jsx)(n.code,{children:"Read"}),", accepts input ",(0,r.jsx)(n.code,{children:"p"})," of type ",(0,r.jsx)(n.code,{children:"[]byte"}),", and returns ",(0,r.jsx)(n.code,{children:"n int"})," and ",(0,r.jsx)(n.code,{children:"err error"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"writer-interface",children:"Writer Interface"}),"\n",(0,r.jsxs)(n.p,{children:["where the Reader is like: ",(0,r.jsx)(n.code,{children:"source of input"})," --\x3e ",(0,r.jsx)(n.code,{children:"Reader"})," --\x3e ",(0,r.jsx)(n.code,{children:"[]byte"})]}),"\n",(0,r.jsxs)(n.p,{children:["Writer is like: ",(0,r.jsx)(n.code,{children:"[]byte"})," --\x3e ",(0,r.jsx)(n.code,{children:"Writer"})," --\x3e ",(0,r.jsx)(n.code,{children:"source of output"})]}),"\n",(0,r.jsxs)(n.p,{children:['What, in the "standard library", implements the Writer interface? ',(0,r.jsx)(n.code,{children:"io.Copy()"})]}),"\n",(0,r.jsx)(n.p,{children:"So this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-golang",children:"  bs := make([]byte, 99999) //fixed byte size 99999 empty elements\n  resp.Body.Read(bs)\n  fmt.Println(string(bs))\n"})}),"\n",(0,r.jsx)(n.p,{children:"does the same thing as this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-golang",children:"io.Copy(os.Stdout, resp.Body)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["where ",(0,r.jsx)(n.code,{children:"resp"})," is from ",(0,r.jsx)(n.code,{children:'resp, err := http.Get("http://google.com")'})]}),"\n",(0,r.jsxs)(n.p,{children:["Copy interface, takes two types: ",(0,r.jsx)(n.code,{children:"func Copy(dst Writer, src Reader) (written int64, err error)"})," a ",(0,r.jsx)(n.code,{children:"Writer"}),' or "something that implements the Writer interface" and a ',(0,r.jsx)(n.code,{children:"Reader"}),' or "something that implements the Reader interface" e.g. ',(0,r.jsx)(n.code,{children:"io.Copy(os.Stdout, resp.Body)"})," i.e. ",(0,r.jsx)(n.code,{children:"io.Copy"})," implmements the ",(0,r.jsx)(n.code,{children:"Writer"})," interface, and ",(0,r.jsx)(n.code,{children:"resp.Body"})," implements the Reader interface."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>o});var i=s(96540);const r={},t=i.createContext(r);function c(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);